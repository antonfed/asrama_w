<html>
    <head>
        <meta charset="utf-8">
        <title>JS 3D Physics</title>
        <link rel="stylesheet" href="css/touch-pad.css">
    	<link rel="stylesheet" href="css/main.css">
        <style>
            body { margin: 0; }
        </style>
    </head>
    <body>
    	

    	<audio id="song" preload="auto" style="display: none">
			<source src="sounds/radio01.mp3">
		</audio>
		<audio id="song2" preload="auto" style="display: none">
			<source src="sounds/radio02.mp3">
		</audio>
    	<script src="jsm/libs/ammo.wasm.js"></script>
    	<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>
		        <script type="module">
        	import * as THREE from 'three';
        	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        	import { Gyroscope } from 'three/addons/misc/Gyroscope.js';
        	import TouchControls from './js/TouchControls.js'
            const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

        


const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize( window.innerWidth, window.innerHeight );
document.body.appendChild( renderer.domElement );

const controls = new OrbitControls( camera, renderer.domElement );
controls.target.set( 0, 0, 0 );
controls.update(); 

const textureLoader = new THREE.TextureLoader();
textureLoader.crossOrigin = '';//this is just to load from imgur

/*create a shader material with a standard vertexShader. Pass the */
const shaderMaterial = new THREE.ShaderMaterial({
  

  uniforms: {
    iChannel0:{value:textureLoader.load("./textures/map.png")},
    iChannel1:{value:textureLoader.load("./textures/sand.jpg")}
  },
  vertexShader: `
    varying vec2 vUv;
        
    void main()
    {
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

      vUv = uv;
    }
  `,
  fragmentShader: `
  
    uniform sampler2D iChannel0;
    uniform sampler2D iChannel1;
    
    //get the uv from the vertex shader above
    varying vec2 vUv;
    
    void main() {
    //get the uv coordinates from the vertex shader
      vec2 uv = vUv;
      vec2 uv2 = vUv;
      uv[0] = mod(vUv[0]*2.0,1.0);
      uv[1] = mod(vUv[1]*2.0,1.0);

        vec4 image1 = texture2D(iChannel0, uv);
        vec4 image2 = texture2D(iChannel1, uv2);

        //set the color RGB values
        gl_FragColor = image1*image2;
    }
  `,
  wireframe: false
});
const planeGeometry = new THREE.PlaneGeometry( 200, 100 );
const plane = new THREE.Mesh( planeGeometry, shaderMaterial );//create a plane to add the shader to
scene.add(plane);



camera.position.z = 100;

function animate() {
  requestAnimationFrame( animate );
  renderer.render( scene, camera );
};

animate();

/*handle resizing */

function onWindowResize(){
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.aspect = THREE.MathUtils.clamp(camera.aspect, 9/16, 16/9);
		camera.updateProjectionMatrix();


  let renderWidth = window.innerWidth;
  let renderHeight = window.innerHeight;

  if(renderWidth/renderHeight>16/9){
    renderHeight = renderWidth*9/16;
  }
  if(renderWidth/renderHeight<9/16){
    renderWidth = renderHeight*9/16;
  }
		renderer.setSize(renderWidth, renderHeight );
		renderer.setPixelRatio( Math.max(1, window.devicePixelRatio));

}

window.addEventListener("resize", onWindowResize);
onWindowResize();
        </script>
    </body>
</html>