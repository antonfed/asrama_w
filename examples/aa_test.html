<html>
    <head>
        <meta charset="utf-8">
        <META name="viewport" content="initial-scale=0.66, user-scalable=no"> 
        <title>JS 3D Physics</title>
        <link rel="stylesheet" href="css/touch-pad.css">
    	<link rel="stylesheet" href="css/main.css">
    	<link type="text/css" rel="stylesheet" href="main.css">
        <style>
        	.ui {    		
    		top: 100px;
			}
			.app
			{
			position: absolute;
    		top: 100px;
    		outline: none;
			margin: 0;
			border:0
			}
			.body
			{
			outline: none;
			margin: 0;
			border:0
			touch-action: none	
			}
			.canvas
			{ outline: none;
			 border: none; }
			.startButton
			{
			display:none;	
			}


        </style>
    </head>
    <body>
    	<progress id="myBar" class="ui" id="loading" value="0" max="100">50%</progress>
    	<progress id="s1" class="ui" id="loading" value="0" max="100">50%</progress>
    	<progress id="s2" class="ui" id="loading" value="0" max="100">50%</progress>
    	<progress id="s3" class="ui" id="loading" value="0" max="100">50%</progress>
    	<div id="overlay">
			<button id="startButton" style="display: none;" class="ui">Play</button>
		</div>
    	

    	<audio id="song1" preload="auto" style="display: none">
			<source src="sounds/radio01_red.mp3">
		</audio>
		<audio id="song2" preload="auto" style="display: none">
			<source src="sounds/radio02_b.mp3">
		<audio id="song3" preload="auto" style="display: none">
			<source src="sounds/radio03.mp3">
		</audio>
    	<script src="jsm/libs/ammo.wasm.js"></script>

    	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    	<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>
		        <script type="module" class="ui">
        	import * as THREE from 'three';
        	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        	import { Gyroscope } from 'three/addons/misc/Gyroscope.js';
        	import TouchControls from './js/TouchControls.js'
            //variable declaration section
            //variable declaration section
            let physicsWorld, scene, camera, renderer, rigidBodies = [], tmpTrans = null , clock
            let ballObject = null, moveDirection = { left: 0, right: 0, forward: 0, back: 0 }
            let ball;
            let kObject = null, kMoveDirection = { left: 0, right: 0, forward: 0, back: 0 }, tmpPos = new THREE.Vector3(), tmpQuat = new THREE.Quaternion();
            let ammoTmpPos = null, ammoTmpQuat = null;

            const STATE = { DISABLE_DEACTIVATION : 4 }

            const FLAGS = { CF_KINEMATIC_OBJECT: 2 }

            // Heightfield parameters
			const terrainWidthExtents = 3000;
			const terrainDepthExtents = 3000;
			const terrainWidth = 512;
			const terrainDepth = 512;
			const terrainHalfWidth = terrainWidth / 2;
			const terrainHalfDepth = terrainDepth / 2;
			const terrainMaxHeight = 300;
			const terrainMinHeight = 0;

			let heightData = null;
			let ammoHeightData = null;
			let terrainMesh;
			let img;
			let scale;
			let gyro;
			let ballHolder = new THREE.Object3D();
			let cameraHolder = new THREE.Object3D();;
			let controls;
			let loader;
			let hover = new THREE.Object3D();

			let sky;
			let smoothX = Array(15).fill(0);
			let smoothZ = Array(7).fill(0);
			let smoothPY = Array(7).fill(0);
			let smoothI = Array(25).fill(0);
			let mouse;
			let moveZ=0.0;
			let moveX=0.0;

			let textureCube;
			let scene_no_fog;
			let song1,song2,song3;
			let container;
			let ctrl;

			let width, height;
			let dirLight;
			let animPolesTexture;

			let sc01,sc02,sc03
			let tileXmin = -2;
			let tileXmax = 2;
			let tileZmin = -2;
			let tileZmax = 2;
			let tileStep = -3001.5;

			let musicLoad = 3;
			let geoLoad = 1;
			let sound1,sound2,sound3;

// vertex shader
THREE.ShaderChunk.fog_pars_vertex += `
#ifdef USE_FOG
  varying vec3 vWorldPosition;
#endif
`;

THREE.ShaderChunk.fog_vertex += `
#ifdef USE_FOG
  vWorldPosition = worldPosition.xyz;
#endif
`;

// fragment shader
THREE.ShaderChunk.fog_pars_fragment += `
#ifdef USE_FOG
  varying vec3 vWorldPosition;

  float fogHeight = 1200.0;
#endif
`;

const FOG_APPLIED_LINE = 'gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );';
THREE.ShaderChunk.fog_fragment = THREE.ShaderChunk.fog_fragment.replace(FOG_APPLIED_LINE, `
  float fogFactor2 = smoothstep( fogHeight, 400.0, vWorldPosition.y );
 
  fogFactor = fogFactor*fogFactor2;

  ${FOG_APPLIED_LINE}
`);

document.getElementById("startButton").style.display = "none";

			//const viewer = document.getElementById( 'viewer' );

			const manager = new THREE.LoadingManager();

			manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
			

			
			console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );

			};

			manager.onLoad = function ( ) {

			console.log( 'Loading complete!');
			geoLoad = 0;
			if(musicLoad==0&&geoLoad==0){ready()};

			};

			manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {

			
			var elem = document.getElementById("myBar");
			elem.value = itemsLoaded/itemsTotal*100;
			console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
			};	
			
			Ammo().then(start);

			
            
            function ready()
            	{
            		document.getElementById("startButton").style.display = "block";
					const startButton = document.getElementById( 'startButton' );
					startButton.addEventListener( 'click', prestart );
            	}

            function prestart (){
            	const overlay = document.getElementById( 'overlay' );
            	const myBar = document.getElementById( 'myBar' );
            	document.getElementById( 's1' ).remove();
            	document.getElementById( 's2' ).remove();
            	document.getElementById( 's3' ).remove();
				overlay.remove();
				myBar.remove();


            	

            	width = window.innerWidth
    			height = window.innerHeight
            	addControls();
            	renderFrame();
            	sound1.play()
            	sound2.play()
            	sound3.play()
            	
            	
            }

			function addControls() {
			    // Camera

			    let aspect = width / height
			    let viewAngle = 45
				let near = 1
				let far = 300
			    let camera_mew = new THREE.PerspectiveCamera(viewAngle, aspect, near, far)
			    // Controls
			    let options = {
			        delta: 0.75,           // coefficient of movement
			        moveSpeed: 0.5,        // speed of movement
			        rotationSpeed: 0.002,  // coefficient of rotation
			        maxPitch: 55,          // max camera pitch angle
			        hitTest: false,         // stop on hitting objects
			        hitTestDistance: 40    // distance to test for hit
			    }

			    ctrl = new TouchControls(document.body, camera_mew, options)

			}


            function start (){

            	loader = new GLTFLoader(manager).setPath( 'models/gltf/' );
                

                setupPhysicsWorld();               
				getHeightData();
				setupGraphics();
				setupMusic();
                createBall();
      
	            
	            }

                
            function make_terrain() {
	            const groundShape = createTerrainShape();


	            for (let i =tileXmin-1; i <= tileXmax+1; i++) {
						for (let j =tileZmin-1; j <= tileZmax+1; j++) {
							const groundTransform = new Ammo.btTransform();
							groundTransform.setIdentity();
							// Shifts the terrain, since bullet re-centers it on its bounding box.
							groundTransform.setOrigin( new Ammo.btVector3( tileStep*j, ( terrainMaxHeight + terrainMinHeight ) / 2, tileStep*i ) );
							const groundMass = 0;
							const groundLocalInertia = new Ammo.btVector3( 0, 0, 0 );
							const groundMotionState = new Ammo.btDefaultMotionState( groundTransform );
							const groundBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( groundMass, groundMotionState, groundShape, groundLocalInertia ) );
							physicsWorld.addRigidBody( groundBody );
				}};
				for (let i =0; i <= 1; i+=1) {
					for (let j =-1; j <= 1; j+=2) {
						let bordersShape;
						let geometry;
						let wall_len = 14000;
						let wall_th = 50;
						let wall_x = i*j*7000;
						let wall_z = (1-i)*j*7000;
						if(i==0){bordersShape = new Ammo.btBoxShape(new Ammo.btVector3(wall_len,500,wall_th));
						geometry = new THREE.BoxGeometry(wall_len,200,wall_th,wall_len/100,1,1);
						}
						if(i!=0){bordersShape = new Ammo.btBoxShape(new Ammo.btVector3(wall_th,500,wall_len));
						geometry = new THREE.BoxGeometry(wall_th,200,wall_len,1,1,wall_len/100);
						}
						console.log(i)						
						
						const material = new THREE.MeshBasicMaterial( {color: 0x00ff00,} );
						material.wireframe = true;
						const cube = new THREE.Mesh( geometry, material );
						cube.position.x =wall_x;
						cube.position.z =wall_z;
						cube.position.y =100;
						scene.add( cube );	
		                bordersShape.setMargin( 0.05 );
						const bordersTransform = new Ammo.btTransform();
						bordersTransform.setIdentity();
						bordersTransform.setOrigin(new Ammo.btVector3(wall_x,0,wall_z));
						const bordersMass = 0;
						const bordersLocalInertia = new Ammo.btVector3( 0, 0, 0 );
						const bordersMotionState = new Ammo.btDefaultMotionState( bordersTransform );
						const bordersBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( bordersMass, bordersMotionState, bordersShape, bordersLocalInertia ) );
						physicsWorld.addRigidBody( bordersBody );
				}};
				
				




				const geometry = new THREE.PlaneGeometry( terrainWidthExtents, terrainDepthExtents, terrainWidth - 1, terrainDepth - 1 );
					geometry.rotateX( - Math.PI / 2 );

					const vertices = geometry.attributes.position.array;

					for ( let i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {

						// j + 1 because it is the y component that we modify
						vertices[ j + 1 ] = heightData[ i ];

					}

					geometry.computeVertexNormals();

					//const groundMaterial = new THREE.MeshPhongMaterial( { color: 0xC7C7C7 } );
					//terrainMesh = new THREE.Mesh( geometry, groundMaterial );
					//terrainMesh.receiveShadow = true;
					//terrainMesh.castShadow = true;
					//scene.add( terrainMesh );

				}

			function getHeightData(scale) {
     
     			if (scale == undefined) scale=1;
     			img = new Image();
     			img.src = "./textures/map.png";
        		var canvas = document.createElement( 'canvas' );
        		canvas.width = terrainWidth;
        		canvas.height = terrainDepth;
        		var context = canvas.getContext( '2d' );
        		var size = terrainWidth * terrainDepth;
        		var data = new Float32Array( size );
        		img.onload = function () {
	        		context.drawImage(img,0,0);
	        		var imgd = context.getImageData(0, 0, terrainWidth, terrainDepth);
	        		var pix = imgd.data;
	        		

	        	for ( var i = 0; i < size; i ++ ) {
	        		    data[i] = 0
	        		}

        		var j=0;
        		for(var i = 0; i<pix.length; i +=4) {
         			var all = pix[i]+pix[i+1]+pix[i+2];

            		data[j++] = all/(12.0*scale)*3.65
            		
        			}
        			heightData = data;
        			//console.log(heightData);
	        		make_terrain()
	        	}	        	

        		

    		}

            function createTerrainShape() {

				// This parameter is not really used, since we are using PHY_FLOAT height data type and hence it is ignored
				const heightScale = 1;

				// Up axis = 0 for X, 1 for Y, 2 for Z. Normally 1 = Y is used.
				const upAxis = 1;

				// hdt, height data type. "PHY_FLOAT" is used. Possible values are "PHY_FLOAT", "PHY_UCHAR", "PHY_SHORT"
				const hdt = 'PHY_FLOAT';

				// Set this to your needs (inverts the triangles)
				const flipQuadEdges = false;

				// Creates height data buffer in Ammo heap
				ammoHeightData = Ammo._malloc( 4 * terrainWidth * terrainDepth );

				// Copy the javascript height data array to the Ammo one.
				let p = 0;
				let p2 = 0;

				for ( let j = 0; j < terrainDepth; j ++ ) {

					for ( let i = 0; i < terrainWidth; i ++ ) {

						// write 32-bit float data to memory
						Ammo.HEAPF32[ ammoHeightData + p2 >> 2 ] = heightData[ p ];

						p ++;

						// 4 bytes/float
						p2 += 4;

					}

				}

				// Creates the heightfield physics shape
				const heightFieldShape = new Ammo.btHeightfieldTerrainShape(
					terrainWidth,
					terrainDepth,
					ammoHeightData,
					heightScale,
					terrainMinHeight,
					terrainMaxHeight,
					upAxis,
					hdt,
					flipQuadEdges
				);

				// Set horizontal scale
				const scaleX = terrainWidthExtents / ( terrainWidth - 1 );
				const scaleZ = terrainDepthExtents / ( terrainDepth - 1 );
				heightFieldShape.setLocalScaling( new Ammo.btVector3( scaleX, 1, scaleZ ) );

				heightFieldShape.setMargin( 1.0 );
				return heightFieldShape;

			}

            function setupPhysicsWorld(){

            	tmpTrans = new Ammo.btTransform();
                ammoTmpPos = new Ammo.btVector3();
                ammoTmpQuat = new Ammo.btQuaternion();

                let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
                    dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
                    overlappingPairCache    = new Ammo.btDbvtBroadphase(),
                    solver                  = new Ammo.btSequentialImpulseConstraintSolver();

                physicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
                physicsWorld.setGravity(new Ammo.btVector3(0, -80, 0));


            }

            function setupMusic(){
            	const listener = new THREE.AudioListener();
				camera.add( listener );

				//SPHERE

				const material1 = new THREE.MeshPhongMaterial( { color: 0xffaa00, flatShading: true, shininess: 0 } );
				const sphere = new THREE.SphereGeometry( 20, 32, 16 );



            	

				sound1 = new THREE.PositionalAudio( listener );
				sound1.setLoop(true);
				sound2 = new THREE.PositionalAudio( listener );
				sound2.setLoop(true);
				sound3 = new THREE.PositionalAudio( listener );
				sound3.setLoop(true);

				const loaderMusic = new THREE.AudioLoader(manager);
				loaderMusic.load('sounds/radio01_x.mp3',
					function ( audioBuffer ) {						
						sound1.setBuffer( audioBuffer );
						musicLoad-=1;
						if(musicLoad==0&&geoLoad==0){ready()};
						console.log( 'song1 play' );
						var elem = document.getElementById("s1");
						elem.value = 100;
						},
					function ( xhr ) {
						
					},
					function ( err ) {console.log( 'An error happened' );}
				);
				loaderMusic.load('sounds/radio02_x.mp3',
					function ( audioBuffer ) {						
						console.log( 'song2 play' );
						sound2.setBuffer( audioBuffer );
						musicLoad-=1;
						if(musicLoad==0&&geoLoad==0){ready()};
						console.log( 'song2 play' );
						var elem = document.getElementById("s2");
						elem.value = 100;
						},
					function ( xhr ) {

					},
					function ( err ) {console.log( 'An error happened' );}
				);
				loaderMusic.load('sounds/radio03.mp3',
					function ( audioBuffer ) {
						console.log( 'song3 play' );						
						sound3.setBuffer( audioBuffer );
						musicLoad-=1;
						if(musicLoad==0&&geoLoad==0){ready()};
						var elem = document.getElementById("s3");
						elem.value = 100;
						},
					function ( xhr ) {

					},
					function ( err ) {console.log( 'An error happened' );}
				);

				//song1 = document.getElementById( 'song1' );
				//sound1.setMediaElementSource( song1 );
				sound1.setRefDistance( 40 );
				sound2.setRefDistance( 40 );
				sound3.setRefDistance( 40 );
				//sound1.setMaxDistance(100);
				//sound1.startTime = 1000.0;
				//song1.play();
				
				const mesh1 = new THREE.Mesh( sphere, material1 );
				mesh1.position.set( 0, 0, 0 );				
				const mesh2 = new THREE.Mesh( sphere, material1 );
				mesh2.position.set( -3000, 0, 0 );
				const mesh3 = new THREE.Mesh( sphere, material1 );
				mesh3.position.set( -3000, 0, -3000 );
				mesh1.add( sound1 );
				mesh2.add( sound2 );
				mesh3.add( sound3 );
				scene.add( mesh2 );
				scene.add( mesh3 );
				scene.add( mesh1 );								
            }

            //
            //
            //
            //
            //
            //
            //
            //

            function setupGraphics(){

                //create clock for timing
                clock = new THREE.Clock();

                //create the scene
                scene = new THREE.Scene();
                scene_no_fog = new THREE.Scene();
                scene.background = new THREE.Color( 0xbfd1e5 );
                var amb =  new THREE.AmbientLight( 0xf0f0f0 )
                amb.intensity = 0.5;
                scene.add(amb);
                scene_no_fog.add( new THREE.AmbientLight( 0xf0f0f0 ) );

                //scene.background = new THREE.Color( 0x5e7bbf );
                scene_no_fog.fog = new THREE.FogExp2( 0xf7e0c8, 0.0002 );
                scene.fog = new THREE.FogExp2( 0xf7e0c8, 0.003 );
                
                camera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 10000 );
                
				camera.position.set( 0, 10, 30 );
				camera.rotation.set( -0.1, 0, 0 );
				cameraHolder.add(camera);
                ballHolder.add(cameraHolder);

                
                	

                //Add directional light
                dirLight = new THREE.DirectionalLight( 0xffc68a , 1);
                //dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( -1, 1.75, 1 );
                dirLight.position.multiplyScalar( 100 );
                scene.add( dirLight );

                dirLight.castShadow = true;
                dirLight.intensity = 3;

                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;

                dirLight.shadow.radius =7;

                let d = 30;

                dirLight.shadow.camera.left = -d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = -d;

                dirLight.shadow.camera.far = 13500;
                
                dirLight.target.position.y = -1;
                dirLight.target.position.z = -1;
                dirLight.target.position.x = -1;
                ballHolder.add(dirLight);
                ballHolder.add(dirLight.target);


                //Setup the renderer

                //renderer = new THREE.WebGLRenderer( { antialias: true } );
                //renderer.setClearColor( 0xbfd1e5 );
                //renderer.setPixelRatio( window.devicePixelRatio );
                //renderer.setSize( window.innerWidth, window.innerHeight );
                

                //renderer.gammaInput = true;
                //renderer.gammaOutput = true;

               
                renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;
				renderer.autoClear = false;
				container = document.body.appendChild( renderer.domElement );
				/*
				if ( /(iPad|iPhone|iPod)/g.test( navigator.userAgent ) ) {

					container.style.width = getComputedStyle( viewer ).width;
					container.style.height = getComputedStyle( viewer ).height;
					container.setAttribute( 'scrolling', 'no' );
				}
				*/ 

				//
                //
                //
                //
                //
                //
                //
                //

				

				const loader_env = new THREE.CubeTextureLoader();
				loader_env.setPath( 'textures/cube/pisa/' );
                textureCube = loader_env.load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ] );
				textureCube.encoding = THREE.sRGBEncoding;

				var alphaMap = new THREE.TextureLoader().load('textures/c_col.jpg');
				var land_light_map = new THREE.TextureLoader().load('textures/land_lightmap_tets.png');
				var land_map = new THREE.TextureLoader().load('textures/sand2.jpg');
				land_map.wrapS = land_map.wrapT = THREE.RepeatWrapping;
				land_light_map.wrapS = land_light_map.wrapT = THREE.RepeatWrapping;


				const land_mat = new THREE.MeshStandardMaterial( { 
    						//lightMap: land_light_map, 
    						map: land_light_map,
    						color: 0x000000,
    						//flatShading: true 
    						//lightMapIntensity: 0.5

						} );



                const sphereMaterial = new THREE.MeshStandardMaterial( { 
    						color: 0,

    						metalness: 0,
    						envMap: textureCube, // optional environment map
    						envMapIntensity: 20,
    						specular: 0xffc382,
    						shininess: 30,
    						roughness: 0.2,
    						fog: false
						} );
                const sphereMaterialtr = new THREE.MeshStandardMaterial( { 
    						color: 0,

    						metalness: 0,
    						envMap: textureCube, // optional environment map
    						envMapIntensity: 20,
    						specular: 0xffc382,
    						shininess: 30,
    						roughness: 0.2
						} );                

				loader.load( 'hover.glb', function ( gltf ) {
					gltf.scene.traverse( function( node ) {
        				if ( node.isMesh ) { node.castShadow = true; }
    				} );
					hover.add( gltf.scene );
					ballHolder.add( hover );
				} );

				scene.add(ballHolder);

                loader.load( 'sky.glb', function ( gltf ) {
					gltf.scene.position.y = -300;
					//gltf.scene.getObjectByName('sky_out').blending(THREE.AdditiveBlending);
					sky = gltf.scene;
					camera.add( gltf.scene );
				} );
                loader.load( 'output.glb', function ( gltf ) {
                	gltf.scene.getObjectByName('land_out').material.lightMap = gltf.scene.getObjectByName('land_out').material.map;
                	gltf.scene.getObjectByName('land_out').material.map = land_map;
                	gltf.scene.getObjectByName('land_out').material.lightMapIntensity = 70;
                	gltf.scene.getObjectByName('land_out').material.bumpMap = land_map;
                	gltf.scene.getObjectByName('land_out').material.bumpScale =12;
                	gltf.scene.getObjectByName('land_out').material.roughness =1;
                	gltf.scene.getObjectByName('land_out').material.metalness =0;
                	
                	const lod = new THREE.LOD();
                	//var lod00 = new THREE.InstancedMesh( gltf.scene.getObjectByName('land_out').geometry, gltf.scene.getObjectByName('land_out').material, 10)
                	var lod00 = gltf.scene.getObjectByName('land_out');
                	var lod01 = new THREE.Object3D();
                	lod.addLevel( lod00, 2000 );
                	lod.addLevel( lod01, 2500 );
					for (let i =tileXmin; i <= tileXmax; i++) {
						for (let j =tileZmin; j <= tileZmax; j++) {

							const copy = lod.clone();
							copy.receiveShadow = true;
							copy.position.x+=tileStep*j;
							copy.position.z+=tileStep*i;
							scene.add(copy);
					}}
					
                	gltf.scene.traverse( function( node ) {
        				if ( node.isMesh ) { node.receiveShadow = true; }
    				} );
					//scene.add( gltf.scene );
				} );
                loader.load( 'trucks.glb', function ( gltf ) {
                	const lod = new THREE.LOD();
                	var lod00 = gltf.scene.getObjectByName('trucks_out');
                	var lod01 = new THREE.Object3D();
                	lod.addLevel( lod00, 2000 );
                	lod.addLevel( lod01, 2500 );
					for (let i =tileXmin; i <= tileXmax; i++) {
						for (let j =tileZmin; j <= tileZmax; j++) {
							
							const copy = lod.clone();
							copy.receiveShadow = true;
							copy.position.x+=tileStep*j;
							copy.position.z+=tileStep*i;
							scene.add(copy);
					}}
				} );


				loader.load( 'poles.glb', function ( gltf ) {
					animPolesTexture = gltf.scene.getObjectByName('poles_out_anim').material;
					const lod = new THREE.LOD();
                	var lod00 = gltf.scene;
                	var lod01 = new THREE.Object3D();
                	lod.addLevel( lod00, 2000 );
                	lod.addLevel( lod01, 2500 );
					for (let i =tileXmin; i <= tileXmax; i++) {
						for (let j =tileZmin; j <= tileZmax; j++) {
							const copy = lod.clone();
							copy.receiveShadow = true;
							copy.position.x+=tileStep*j;
							copy.position.z+=tileStep*i;
							scene.add(copy);
					}}

				} );
				loader.load( 'theater.glb', function ( gltf ) {
					const lod = new THREE.LOD();
                	var lod00 = gltf.scene.getObjectByName('theater_out');
                	var lod01 = new THREE.Object3D();
                	lod.addLevel( lod00, 2000 );
                	lod.addLevel( lod01, 2500 );
					for (let i =tileXmin; i <= tileXmax; i++) {
						for (let j =tileZmin; j <= tileZmax; j++) {
							const copy = lod.clone();
							copy.receiveShadow = true;
							copy.position.x+=tileStep*j;
							copy.position.z+=tileStep*i;
							scene.add(copy);
					}}
				} );
				loader.load( 'station01.glb', function ( gltf ) {
					
					gltf.scene.getObjectByName('station01_out').material = sphereMaterial;
					

					gltf.scene.getObjectByName('station01_tube_out').material.alphaMap = alphaMap;
					gltf.scene.getObjectByName('station01_tube_out').material.transparent = true;
					sc01 = gltf.scene;
					
					scene.add(sc01);
				} );
				loader.load( 'castle.glb', function ( gltf ) {
					
					scene.add(gltf.scene);
				} );

				
					
				loader.load( 'station02.glb', function ( gltf ) {
					gltf.scene.getObjectByName('station02_out').material = sphereMaterial;
					

					gltf.scene.getObjectByName('station02_tube_out').material.alphaMap = alphaMap;
					gltf.scene.getObjectByName('station02_tube_out').material.transparent = true;
					sc02 = gltf.scene;
					scene.add( sc02 );
				} );
				loader.load( 'station03.glb', function ( gltf ) {

					gltf.scene.getObjectByName('station03_tube_out').material.alphaMap = alphaMap;
					gltf.scene.getObjectByName('station03_tube_out').material.transparent = true;

					gltf.scene.getObjectByName('station03_out').material = sphereMaterial;
					
					sc03 = gltf.scene;
					scene.add( sc03 );
				} );
				loader.load( 'station04.glb', function ( gltf ) {

					//gltf.scene.getObjectByName('station03_tube_out').material.alphaMap = alphaMap;
					//gltf.scene.getObjectByName('station03_tube_out').material.transparent = true;

					gltf.scene.getObjectByName('station04_out').material = sphereMaterial;

					scene.add( gltf.scene );
				} );
            }


            function createBall(){
                
                let pos = {x: 0, y: 200, z: 0};
                let radius = 12;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

                //threeJS Section
                ball = ballObject = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshPhongMaterial({color: 0xff0505}));
                
                ball.position.set(pos.x, pos.y, pos.z);
                
                ball.castShadow = true;
                ball.receiveShadow = true;

                //scene.add(ball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );
                //body.fixedTimeStep = 1 / 500;
                //console.log(body);
                //body.setFriction(2000000);
                //body.setRollingFriction(20000000);
                //body.setRollingFriction(20000000);
                //body.setRestitution(20000000);

                body.setActivationState( STATE.DISABLE_DEACTIVATION );
                //body.setCcdMotionThreshold(0.03);
                //body.setCcdSweptSphereRadius(0.2)


                physicsWorld.addRigidBody( body );
                
                ball.userData.physicsBody = body;
                rigidBodies.push(ball);


				

            }


            function moveBall(){

            	//mouse.x = +(event.targetTouches[0].pageX / window.innerWidth) * 2 +-1;

				//mouse.y = -(event.targetTouches[0].pageY / window.innerHeight) * 2 + 1;
            	
                let scalingFactor = 5;

                moveX +=  kMoveDirection.right - kMoveDirection.left;
                moveZ +=  kMoveDirection.back - kMoveDirection.forward;
                let moveY =  0;
                smoothI.push(moveX); 
                ballHolder.rotation.y-=(smoothI.reduce((a,b) => (a+b)) / smoothI.length)*0.022;
                smoothI.shift();
                //if(moveZ == 0) return;

                var vector = new THREE.Vector3()
                ballHolder.getWorldDirection( vector );
                //console.log(vector.z)
                
                let resultantImpulse = new Ammo.btVector3( vector.x*moveZ, 0, vector.z*moveZ )
                resultantImpulse.op_mul(scalingFactor);

                let physicsBody = ballObject.userData.physicsBody;
                let test = physicsBody.getLinearVelocity();
                //physicsBody.setAngularVelocity(new Ammo.btVector3(0,0,0))
                //physicsBody.setLinearVelocity(test.op_mul(0.97));
                //physicsBody.applyForce( resultantImpulse);
                test.op_add(resultantImpulse);
                physicsBody.setLinearVelocity(test.op_mul(0.97));
                let side = new THREE.Vector3(test.x(),0,test.z());
             	
                let len = side.length()*0.02;
                vector.normalize();
                vector.cross(new THREE.Vector3(0,1,0));
                side.normalize();
                //console.log(len);
                smoothZ.push(vector.dot(side)*len);
                smoothX.push(test.y());
                hover.rotation.x = (smoothX.reduce((a,b) => (a+b)) / smoothX.length)*0.005
                hover.rotation.z = -(smoothZ.reduce((a,b) => (a+b)) / smoothZ.length)*0.4;
                	
                //console.log(smooth.reduce((a,b) => (a+b)) / smooth.length);
                smoothX.shift();
                smoothZ.shift();
                moveX = 0;
                moveZ = 0;



            }

            function updatePhysics( deltaTime ){


            	
            	ballHolder.position.copy(ball.position);
            	smoothPY.push(ball.position.y);
            	ballHolder.position.y = (smoothPY.reduce((a,b) => (a+b)) / smoothPY.length)
	           	smoothPY.shift();

            	let handVec = new THREE.Vector3()
				ballHolder.getWorldPosition(handVec)
				handVec.y+=6;
				handVec.y*=1;
            	//controls.target= handVec;
            	//controls.update();
                // Step world
                

                physicsWorld.stepSimulation( deltaTime,10);


                // Update rigid bodies
                for ( let i = 0; i < rigidBodies.length; i++ ) {
                    let objThree = rigidBodies[ i ];
                    let objAmmo = objThree.userData.physicsBody;
                    let ms = objAmmo.getMotionState();
                    if ( ms ) {

                        ms.getWorldTransform( tmpTrans );
                        let p = tmpTrans.getOrigin();
                        let q = tmpTrans.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                    }
                }	

            }

            function renderFrame(){

                let deltaTime = clock.getDelta();
                
                //animPolesTexture.map.offset.y += deltaTime*0.3;

                //sc01.children[0].children[0].rotation.y +=deltaTime*0.3;
                //sc02.children[0].children[0].rotation.y +=deltaTime*0.3;
                //sc03.children[0].children[0].rotation.y +=deltaTime*0.3;
                moveBall();
                cameraHolder.rotation.y = ctrl.rot.y*2;
                //console.log(ctrl.rot)
                ctrl.update();
                moveX = ctrl.velocity.x*1.5;
                moveZ = ctrl.velocity.z*1.5;

                updatePhysics( deltaTime );
                renderer.clear();
				renderer.render( scene, camera );
				renderer.clearDepth();
				renderer.render( scene_no_fog, camera );

                requestAnimationFrame( renderFrame );

            }

            function setupEventHandlers(){

                window.addEventListener( 'keydown', handleKeyDown, false);
                window.addEventListener( 'keyup', handleKeyUp, false);
               
            }


        </script>
    </body>
</html>