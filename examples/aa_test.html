<html>
    <head>
        <meta charset="utf-8">

        <META name="viewport" content="initial-scale=0.66, user-scalable=no"> 
        <title>JS 3D Physics</title>
        <link rel="stylesheet" href="css/touch-pad.css">
    	<link rel="stylesheet" href="css/main.css">
    	<link type="text/css" rel="stylesheet" href="main.css">
        <style>
        	.ui {    		
    		top: 100px;
			}
			.app
			{
			position: absolute;
    		top: 100px;
    		outline: none;
			margin: 0;
			border:0
			}
			.body
			{
			outline: none;
			margin: 0;
			border:0
			touch-action: none	
			}
			.canvas
			{
			outline: none;
			border: none; 
			}
			.buttone {
				background: transparent;
				border: 0;
				border: 1px solid rgb(255, 255, 255);
				border-radius: 4px;
				color: #ffffff;
				padding: 12px 18px;
				text-transform: uppercase;
				cursor: pointer;
			}


        </style>
    </head>
    <body>
    	<progress id="myBar" class="ui" id="loading" value="0" max="100">50%</progress>
    	<progress id="s1" class="ui" id="loading" value="0" max="100">50%</progress>
    	<progress id="s2" class="ui" id="loading" value="0" max="100">50%</progress>
    	<progress id="s3" class="ui" id="loading" value="0" max="100">50%</progress>
    	<div id="overlay">
			<button id="startButton" style="display: none;" class="ui">Play</button>
		</div>
		<div id="menu" style="position:absolute; width: 100%; justify-content: center; display: flex;pointer-events:none;">
		<button id="autoButton" class="buttone" style="display: none;" >Auto</button>
		</div>
		<div id="menu" style="position:absolute;  width: 100%;display: flex;justify-content: right;pointer-events:none;">	
		<button id="mapButton" class="buttone" style="display: none; " >Map</button>
		</div>
		<div id="menu" style="position:absolute;pointer-events:none;">
		<button id="shopButton" class="buttone" style="display: none; ">Shop</button>
		</div>



		
    	
    	<script src="jsm/libs/ammo.wasm.js"></script>

    	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>
    	<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>
		        <script type="module" class="ui">
        	import * as THREE from 'three';
        	import { MeshoptDecoder } from 'three/addons/libs/meshopt_decoder.module.js';
        	import { KTX2Loader } from 'three/addons/loaders/KTX2Loader.js';
        	import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        	import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        	import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        	import { Gyroscope } from 'three/addons/misc/Gyroscope.js';
        	import TouchControls from './js/TouchControls.js'
            //variable declaration section
            //variable declaration section
            let physicsWorld, renderer, rigidBodies = [], tmpTrans = null , clock
            let ballObject = null, moveDirection = { left: 0, right: 0, forward: 0, back: 0 }
            let ball;
            let kObject = null, kMoveDirection = { left: 0, right: 0, forward: 0, back: 0 }, tmpPos = new THREE.Vector3(), tmpQuat = new THREE.Quaternion();
            let ammoTmpPos = null, ammoTmpQuat = null;

            const STATE = { DISABLE_DEACTIVATION : 4 }

            const FLAGS = { CF_KINEMATIC_OBJECT: 2 }

            // Heightfield parameters
const terrainWidthExtents = 3000;
const terrainDepthExtents = 3000;
const terrainWidth = 256;
const terrainDepth = 256;
const terrainHalfWidth = terrainWidth / 2;
const terrainHalfDepth = terrainDepth / 2;
const terrainMaxHeight = 300;
const terrainMinHeight = 0;

let heightData = null;
let ammoHeightData = null;
let terrainMesh;
let img;
let scale;
let gyro;
let ballHolder = new THREE.Object3D();
let cameraHolder = new THREE.Object3D();;
let controls;
let loader;
let hover = new THREE.Object3D();

let sky;
let smoothX = Array(15).fill(0);
let smoothZ = Array(7).fill(0);
let smoothPY = Array(7).fill(0);
let smoothI = Array(25).fill(0);
let mouse;
let moveZ=0.0;
let moveX=0.0;

let textureCube;
let scene_no_fog;
let song1,song2,song3;
let container;
let ctrl;

let width, height;
let dirLight;
let animPolesTexture;

let sc01,sc02,sc03
let tileXmin = -2;
let tileXmax = 2;
let tileZmin = -2;
let tileZmax = 2;
let tileStep = -3001.5;

let musicLoad = 3;
let geoLoad = 1;
let sound1,sound2,sound3;

let mapCamera;
let playerCamera
let activeCamera;
let shopCamera;

let mapScene;
let playerScene;
let activeScene;
let shopScene;

let mixer;
let placer;

let intersect_map = [];
let characterPath;
let characterCurve;
let pt =[];

let autoMode = 0;

let positions = [];
const ARC_SEGMENTS = 200;
let firstFrame = true;


// vertex shader
THREE.ShaderChunk.fog_pars_vertex += `
#ifdef USE_FOG
  varying vec3 vWorldPosition;
#endif
`;

THREE.ShaderChunk.fog_vertex += `
#ifdef USE_FOG
  vWorldPosition = worldPosition.xyz;
#endif
`;

// fragment shader
THREE.ShaderChunk.fog_pars_fragment += `
#ifdef USE_FOG
  varying vec3 vWorldPosition;

  float fogHeight = 1200.0;
#endif
`;

const FOG_APPLIED_LINE = 'gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );';
THREE.ShaderChunk.fog_fragment = THREE.ShaderChunk.fog_fragment.replace(FOG_APPLIED_LINE, `
  float fogFactor2 = smoothstep( fogHeight, 400.0, vWorldPosition.y );
 
  fogFactor = fogFactor*fogFactor2;

  ${FOG_APPLIED_LINE}
`);



//MANAGER
const manager = new THREE.LoadingManager();

manager.onStart = function ( url, itemsLoaded, itemsTotal ) {
//console.log( 'Started loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
};

manager.onLoad = function ( ) {
//console.log( 'Loading complete!');
geoLoad = 0;
if(musicLoad==0&&geoLoad==0){timerReady()};
};

manager.onProgress = function ( url, itemsLoaded, itemsTotal ) {
var elem = document.getElementById("myBar");
elem.value = itemsLoaded/itemsTotal*100;
//console.log( 'Loading file: ' + url + '.\nLoaded ' + itemsLoaded + ' of ' + itemsTotal + ' files.' );
};	
			
Ammo().then(start);

function start () {
	setupPhysicsWorld();               
	setupGraphics();
	setupMusic();

	make_collisionShape();
	make_borderShape();
	make_groundShape();


	createBall();
	createInteractiveBall();
}	

function timerReady(){setTimeout(ready, 3000)};            
function ready() {
document.getElementById("startButton").style.display = "block";
document.getElementById( 'startButton').addEventListener( 'click', levelStart );;

const mapButton = document.getElementById( 'mapButton' );
mapButton.addEventListener( 'click', mapChange );
const shopButton = document.getElementById( 'shopButton' );
shopButton.addEventListener( 'click', shopChange );
const autoButton = document.getElementById( 'autoButton' );
autoButton.addEventListener( 'click', autoChange );
}



function levelStart() {


	playerScene.traverse( function( node ) {
		if ( node.isMesh ) { 

			node.frustumCulled = false;
			node.onAfterRender = function(){node.frustumCulled = true;node.onAfterRender = function(){};};};
	});


	document.getElementById( 'overlay' ).remove();
	document.getElementById( 'myBar' ).remove();
	document.getElementById( 's1' ).remove();
	document.getElementById( 's2' ).remove();
	document.getElementById( 's3' ).remove();
	            	
	width = window.innerWidth
	height = window.innerHeight
	
	addControls();
	document.getElementById("mapButton").style.display = "block";
	document.getElementById("shopButton").style.display = "block";



	
  //renderer.render( activeScene, activeCamera );
	sound1.play();
	sound2.play();
	sound3.play();
	renderFrame();
	
}

function addControls() {
	// Camera

	let aspect = width / height
	let viewAngle = 45
	let near = 1
	let far = 300
	let camera_mew = new THREE.PerspectiveCamera(viewAngle, aspect, near, far)
	// Controls
	let options = {
	delta: 0.75,           // coefficient of movement
	moveSpeed: 0.5,        // speed of movement
	rotationSpeed: 0.002,  // coefficient of rotation
	maxPitch: 55,          // max camera pitch angle
	hitTest: false,         // stop on hitting objects
	hitTestDistance: 40    // distance to test for hit
	}

	ctrl = new TouchControls(document.body, camera_mew, options);
}



				/*******
				 * Curves
				 *********/
	        function createCharacterPath(pos){
				

	        	characterCurve = new THREE.CatmullRomCurve3(pos);
				pt = characterCurve.getPoints( 30 );
				const geometry = new THREE.BufferGeometry().setFromPoints( pt );

				const material = new THREE.LineBasicMaterial( { color: 0xff0000 } );

				// Create the final object to add to the scene
				const curveObject = new THREE.Line( geometry, material );
				mapScene.remove(characterPath);
				characterPath = curveObject;
				mapScene.add(characterPath);
				}

			//document.addEventListener( 'mousedown', onDocumentMouseDown );
			function onDocumentMouseDown( event ) {    
	            if(activeCamera == mapCamera){
	            	event.preventDefault();
		            var mouse3D = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1,   
		                                    -( event.clientY / window.innerHeight ) * 2 + 1,  
		                                    0.5 );
		            var playerWP = new THREE.Vector3();                             
		            var targetWP = new THREE.Vector3();
		            var raycaster = new THREE.Raycaster();                                        
		           	raycaster.setFromCamera( mouse3D, mapCamera );
		            var intersects = raycaster.intersectObjects( mapScene.children );
		            if ( intersects.length > 0 ) {
		            	var obj = intersects[ 0 ].object;
		            	obj.getWorldPosition(targetWP);
						ballHolder.getWorldPosition(playerWP);
		                var pos = [
		            	playerWP,
						new THREE.Vector3( Math.random() * 3000, 50, Math.random() * 3000 ),
						new THREE.Vector3( Math.random() * 3000, 50, Math.random() * 3000 ),

						targetWP,
						]
		                autoMode = 1;
		                document.getElementById("autoButton").style.display = "block";
						createCharacterPath(pos);
					}
	            }
	        }



				






            

function make_collisionShape() {
    	
	var collisionShape;
	const loader = new GLTFLoader().setPath( 'models/gltf/' );
	loader.load( 'wagon_collision.glb', function ( gltf ) {
		gltf.scene.traverse( function( node ) {
			if ( node.isMesh ) {
				node.updateMatrix();
				node.updateWorldMatrix(true,false);
				collisionShape = col_mesh(node);
		

				collisionShape.setMargin(3);
	      const colTransform = new Ammo.btTransform();
					colTransform.setIdentity();
			
				colTransform.setOrigin( new Ammo.btVector3( 0, 0, 0 ) );
				const colMass = 0;
				const colLocalInertia = new Ammo.btVector3( 0, 0, 0 );
				const colMotionState = new Ammo.btDefaultMotionState( colTransform );
				const colBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( colMass, colMotionState, collisionShape, colLocalInertia ) );
				physicsWorld.addRigidBody( colBody );
			}
		});
	});
}
				
function make_groundShape() {

	img = new Image();
	img.src = "./textures/map.png";
	var canvas = document.createElement( 'canvas' );
	canvas.width = terrainWidth;
	canvas.height = terrainDepth;
	var context = canvas.getContext( '2d' );
	var size = terrainWidth * terrainDepth;
	var data = new Float32Array( size );
	img.onload = function () {
		context.drawImage(img,0,0);
		var imgd = context.getImageData(0, 0, terrainWidth, terrainDepth);
		var pix = imgd.data;
		

		for ( var i = 0; i < size; i ++ ) {data[i] = 0}
		var j=0;
		for(var i = 0; i<pix.length; i +=4) {var all = pix[i]+pix[i+1]+pix[i+2];data[j++] = all/(12.0)*3.65}
		heightData = data;

		const groundShape = createTerrainShape();
		//multiple collision landscapes
		for (let i =tileXmin-2; i <= tileXmax+2; i++) {
			for (let j =tileZmin-2; j <= tileZmax+2; j++) {
				const groundTransform = new Ammo.btTransform();
				groundTransform.setIdentity();
				// Shifts the terrain, since bullet re-centers it on its bounding box.
				groundTransform.setOrigin( new Ammo.btVector3( tileStep*j, ( terrainMaxHeight + terrainMinHeight ) / 2, tileStep*i ) );
				const groundMass = 0;
				const groundLocalInertia = new Ammo.btVector3( 0, 0, 0 );
				const groundMotionState = new Ammo.btDefaultMotionState( groundTransform );
				const groundBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( groundMass, groundMotionState, groundShape, groundLocalInertia ) );
				physicsWorld.addRigidBody( groundBody );
		}};
	}
						/*
					const geometry = new THREE.PlaneGeometry( terrainWidthExtents, terrainDepthExtents, terrainWidth - 1, terrainDepth - 1 );
					geometry.rotateX( - Math.PI / 2 );
					const vertices = geometry.attributes.position.array;
					for ( let i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {
						vertices[ j + 1 ] = heightData[ i ];
					}
					geometry.computeVertexNormals();
					//const groundMaterial = new THREE.MeshPhongMaterial( { color: 0xC7C7C7 } );
					//terrainMesh = new THREE.Mesh( geometry, groundMaterial );
					//scene.add( terrainMesh );
          */
}

function make_borderShape() {				
	for (let i =0; i <= 1; i+=1) {
		for (let j =-1; j <= 1; j+=2) {
			let bordersShape;
			let geometry;
			let wall_len = 14000;
			let wall_th = 50;
			let wall_x = i*j*7000;
			let wall_z = (1-i)*j*7000;
			if(i==0){bordersShape = new Ammo.btBoxShape(new Ammo.btVector3(wall_len,500,wall_th));
			geometry = new THREE.BoxGeometry(wall_len,200,wall_th,wall_len/100,1,1);
			}
			if(i!=0){bordersShape = new Ammo.btBoxShape(new Ammo.btVector3(wall_th,500,wall_len));
			geometry = new THREE.BoxGeometry(wall_th,200,wall_len,1,1,wall_len/100);
			}					
			
			const material = new THREE.MeshBasicMaterial( {color: 0x00ff00,} );
			material.wireframe = true;
			const cube = new THREE.Mesh( geometry, material );
			cube.position.x =wall_x;
			cube.position.z =wall_z;
			cube.position.y =100;
			playerScene.add( cube );	
	            bordersShape.setMargin( 0.05 );
			const bordersTransform = new Ammo.btTransform();
			bordersTransform.setIdentity();
			bordersTransform.setOrigin(new Ammo.btVector3(wall_x,0,wall_z));
			const bordersMass = 0;
			const bordersLocalInertia = new Ammo.btVector3( 0, 0, 0 );
			const bordersMotionState = new Ammo.btDefaultMotionState( bordersTransform );
			const bordersBody = new Ammo.btRigidBody( new Ammo.btRigidBodyConstructionInfo( bordersMass, bordersMotionState, bordersShape, bordersLocalInertia ) );
			physicsWorld.addRigidBody( bordersBody );
	}};
}
				


function createTerrainShape() {

		// This parameter is not really used, since we are using PHY_FLOAT height data type and hence it is ignored
		const heightScale = 1;

		// Up axis = 0 for X, 1 for Y, 2 for Z. Normally 1 = Y is used.
		const upAxis = 1;

		// hdt, height data type. "PHY_FLOAT" is used. Possible values are "PHY_FLOAT", "PHY_UCHAR", "PHY_SHORT"
		const hdt = 'PHY_FLOAT';

		// Set this to your needs (inverts the triangles)
		const flipQuadEdges = false;

		// Creates height data buffer in Ammo heap
		ammoHeightData = Ammo._malloc( 4 * terrainWidth * terrainDepth );

		// Copy the javascript height data array to the Ammo one.
		let p = 0;
		let p2 = 0;

		for ( let j = 0; j < terrainDepth; j ++ ) {

			for ( let i = 0; i < terrainWidth; i ++ ) {

				// write 32-bit float data to memory
				Ammo.HEAPF32[ ammoHeightData + p2 >> 2 ] = heightData[ p ];

				p ++;

				// 4 bytes/float
				p2 += 4;

			}

		}

		// Creates the heightfield physics shape
		const heightFieldShape = new Ammo.btHeightfieldTerrainShape(
			terrainWidth,
			terrainDepth,
			ammoHeightData,
			heightScale,
			terrainMinHeight,
			terrainMaxHeight,
			upAxis,
			hdt,
			flipQuadEdges
		);

		// Set horizontal scale
		const scaleX = terrainWidthExtents / ( terrainWidth - 1 );
		const scaleZ = terrainDepthExtents / ( terrainDepth - 1 );
		heightFieldShape.setLocalScaling( new Ammo.btVector3( scaleX, 1, scaleZ ) );

		heightFieldShape.setMargin( 1.0 );
		return heightFieldShape;

}

function createTriangleShapeByBufferGeometry(geometry, scalingFactor) {
  var mesh = new Ammo.btTriangleMesh(true, true);
  var vertexPositionArray = geometry.attributes.position.array;
  for (var i = 0; i < geometry.attributes.position.count/3; i++) {
          mesh.addTriangle(
              new Ammo.btVector3(vertexPositionArray[i*9+0]*scalingFactor, vertexPositionArray[i*9+1]*scalingFactor, vertexPositionArray[i*9+2]*scalingFactor ),
              new Ammo.btVector3(vertexPositionArray[i*9+3]*scalingFactor, vertexPositionArray[i*9+4]*scalingFactor, vertexPositionArray[i*9+5]*scalingFactor),
              new Ammo.btVector3(vertexPositionArray[i*9+6]*scalingFactor, vertexPositionArray[i*9+7]*scalingFactor, vertexPositionArray[i*9+8]*scalingFactor),
              false
          );
  }
  var shape = new Ammo.btBvhTriangleMeshShape(mesh, true, true);
  return shape;
}
			
function col_mesh(object){

	let triangle, triangle_mesh = new Ammo.btTriangleMesh();

        //declare triangles position vectors
        let vectA = new Ammo.btVector3(0, 0, 0);
        let vectB = new Ammo.btVector3(0, 0, 0);
        let vectC = new Ammo.btVector3(0, 0, 0);

        //retrieve vertices positions from object
        let verticesPos = object.geometry.getAttribute('position').array;
        let triangles = [];
        for (let i = 0; i < verticesPos.length; i += 3) {
            triangles.push({
                x: verticesPos[i],
                y: verticesPos[i + 1],
                z: verticesPos[i + 2]
            })
        }

        //use triangles data to draw ammo shape
        for (let i = 0; i < triangles.length - 3; i += 3) {

            vectA.setX(triangles[i].x);
            vectA.setY(triangles[i].y);
            vectA.setZ(triangles[i].z);

            vectB.setX(triangles[i + 1].x);
            vectB.setY(triangles[i + 1].y);
            vectB.setZ(triangles[i + 1].z);

            vectC.setX(triangles[i + 2].x);
            vectC.setY(triangles[i + 2].y);
            vectC.setZ(triangles[i + 2].z);

            triangle_mesh.addTriangle(vectA, vectB, vectC, true);
        }
	//Ammo vectors should be destroyed after use to avoid memory leak.
				Ammo.destroy(vectA);
        Ammo.destroy(vectB);
        Ammo.destroy(vectC);

	var shape = new Ammo.btBvhTriangleMeshShape(triangle_mesh, true);	
	return shape
}

function setupPhysicsWorld(){

	tmpTrans = new Ammo.btTransform();
    ammoTmpPos = new Ammo.btVector3();
    ammoTmpQuat = new Ammo.btQuaternion();

    let collisionConfiguration  = new Ammo.btDefaultCollisionConfiguration(),
        dispatcher              = new Ammo.btCollisionDispatcher(collisionConfiguration),
        overlappingPairCache    = new Ammo.btDbvtBroadphase(),
        solver                  = new Ammo.btSequentialImpulseConstraintSolver();

    physicsWorld           = new Ammo.btDiscreteDynamicsWorld(dispatcher, overlappingPairCache, solver, collisionConfiguration);
    physicsWorld.setGravity(new Ammo.btVector3(0, -80, 0));
}






















            function setupMusic(){
            	const listener = new THREE.AudioListener();
				playerCamera.add( listener );

				//SPHERE

				const material1 = new THREE.MeshPhongMaterial( { color: 0xffaa00, flatShading: true, shininess: 0 } );
				const sphere = new THREE.SphereGeometry( 20, 32, 16 );



            	

				sound1 = new THREE.PositionalAudio( listener );
				sound1.setLoop(true);
				sound2 = new THREE.PositionalAudio( listener );
				sound2.setLoop(true);
				sound3 = new THREE.PositionalAudio( listener );
				sound3.setLoop(true);

				const loaderMusic = new THREE.AudioLoader(manager);
				loaderMusic.load('sounds/radio01_x.mp3',
					function ( audioBuffer ) {						
						sound1.setBuffer( audioBuffer );
						musicLoad-=1;
						if(musicLoad==0&&geoLoad==0){timerReady()};
						console.log( 'song1 play' );
						var elem = document.getElementById("s1");
						elem.value = 100;
						},
					function ( xhr ) {
						
					},
					function ( err ) {console.log( 'An error happened' );}
				);
				loaderMusic.load('sounds/radio02_x.mp3',
					function ( audioBuffer ) {						
						console.log( 'song2 play' );
						sound2.setBuffer( audioBuffer );
						musicLoad-=1;
						if(musicLoad==0&&geoLoad==0){timerReady()};
						console.log( 'song2 play' );
						var elem = document.getElementById("s2");
						elem.value = 100;
						},
					function ( xhr ) {

					},
					function ( err ) {console.log( 'An error happened' );}
				);
				loaderMusic.load('sounds/radio03.mp3',
					function ( audioBuffer ) {
						console.log( 'song3 play' );						
						sound3.setBuffer( audioBuffer );
						musicLoad-=1;
						if(musicLoad==0&&geoLoad==0){timerReady()};
						var elem = document.getElementById("s3");
						elem.value = 100;
						},
					function ( xhr ) {

					},
					function ( err ) {console.log( 'An error happened' );}
				);

				//song1 = document.getElementById( 'song1' );
				//sound1.setMediaElementSource( song1 );
				sound1.setRefDistance( 1300 );
				//sound1.setMaxDistance(500);
				sound1.setDistanceModel("exponential")
				sound1.setRolloffFactor(6);
				sound2.setRefDistance( 1300 );
				//sound2.setMaxDistance(500);
				sound2.setDistanceModel("exponential")
				sound2.setRolloffFactor(6);
				sound3.setRefDistance( 1300 );
				//sound3.setMaxDistance(500);
				sound3.setRolloffFactor(6);
				sound3.setDistanceModel("exponential")
				//sound1.setMaxDistance(100);
				//sound1.startTime = 1000.0;
				//song1.play();
				
				const mesh1 = new THREE.Mesh( sphere, material1 );
				mesh1.position.set( 0, 0, 0 );				
				const mesh2 = new THREE.Mesh( sphere, material1 );
				mesh2.position.set( -3000, 0, 0 );
				const mesh3 = new THREE.Mesh( sphere, material1 );
				mesh3.position.set( -3000, 0, -3000 );
				mesh1.add( sound1 );
				mesh2.add( sound2 );
				mesh3.add( sound3 );
				playerScene.add( mesh2 );
				playerScene.add( mesh3 );
				playerScene.add( mesh1 );								
            }

            //
            //
            //
            //
            //
            //
            //
            //

            function setupGraphics(){

                //create clock for timing
                clock = new THREE.Clock();

                //create the scene
                playerScene = new THREE.Scene();
                mapScene = new THREE.Scene();
                activeScene = playerScene;

                playerScene.background = new THREE.Color( 0xbfd1e5 );
                mapScene.background = new THREE.Color( 0xffddc4 );
                
                var amb =  new THREE.AmbientLight( 0xf0f0f0 )
                amb.intensity = 0.5;
                playerScene.add(amb);
                playerScene.fog = new THREE.FogExp2( 0xf7e0c8, 0.003 );
                
                playerCamera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 10000 );
                mapCamera = new THREE.PerspectiveCamera( 80, window.innerWidth / window.innerHeight, 1, 10000 );
                shopCamera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 1, 10000 );
                activeCamera = playerCamera;
               
                shopCamera.position.set( 60, 80, -80);

                mapCamera.position.set( 0, 2000, 30 );
                mapCamera.rotation.set( -3.14/2, 0 , 0 );
                
				playerCamera.position.set( 0, 10, 30 );
				playerCamera.rotation.set( -0.1, 0, 0 );
				cameraHolder.add(playerCamera);
        ballHolder.add(cameraHolder);

                
                	

                //Add directional light
                dirLight = new THREE.DirectionalLight( 0xffc68a , 1);
                //dirLight.color.setHSL( 0.1, 1, 0.95 );
                dirLight.position.set( -1, 1.75, 1 );
                dirLight.position.multiplyScalar( 100 );
                playerScene.add( dirLight );

                dirLight.castShadow = true;
                dirLight.intensity = 3;

                dirLight.shadow.mapSize.width = 2048;
                dirLight.shadow.mapSize.height = 2048;

                dirLight.shadow.radius =7;

                let d = 30;

                dirLight.shadow.camera.left = -d;
                dirLight.shadow.camera.right = d;
                dirLight.shadow.camera.top = d;
                dirLight.shadow.camera.bottom = -d;

                dirLight.shadow.camera.far = 13500;
                
                dirLight.target.position.y = -1;
                dirLight.target.position.z = -1;
                dirLight.target.position.x = -1;
                ballHolder.add(dirLight);
                ballHolder.add(dirLight.target);

               
        renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				renderer.toneMappingExposure = 1;
				renderer.outputEncoding = THREE.sRGBEncoding;
				renderer.shadowMap.enabled = true;

				//renderer.debug.checkShaderErrors = false;

				//renderer.compile(playerScene,playerCamera);
				//renderer.getContext().getProgramInfoLog= function() { return '' }
				container = document.body.appendChild( renderer.domElement );
				

				//
                //
                //
                //
                //
                //
                //	
                //

				//LOADER
				const dracoLoader = new DRACOLoader().setDecoderPath('jsm/libs/draco/');
        const ktx2Loader = new KTX2Loader().setTranscoderPath( 'jsm/libs/basis/' ).detectSupport( renderer );
				const loader = new GLTFLoader().setPath( 'models/gltf/' );
							
				loader.setKTX2Loader( ktx2Loader );
				loader.setDRACOLoader(dracoLoader);
				loader.setMeshoptDecoder( MeshoptDecoder );

				const loader_env = new THREE.CubeTextureLoader();
				loader_env.setPath( 'textures/cube/pisa/' );
        textureCube = loader_env.load( [ 'px.png', 'nx.png', 'py.png', 'ny.png', 'pz.png', 'nz.png' ] );
				textureCube.encoding = THREE.sRGBEncoding;

				var alphaMap = new THREE.TextureLoader().load('textures/c_col.jpg');
				//var wag03AlphaMap = new THREE.TextureLoader().load('textures/c_col.jpg');
				//var land_light_map = new THREE.TextureLoader().load('textures/land_lightmap_tets.png');
				var land_map = new THREE.TextureLoader().load('textures/sand2.jpg');
				land_map.wrapS = land_map.wrapT = THREE.RepeatWrapping;
				//land_light_map.wrapS = land_light_map.wrapT = THREE.RepeatWrapping;


				const land_mat = new THREE.MeshStandardMaterial( { 
    						//lightMap: land_light_map, 
    						//map: land_light_map,
    						color: 0x000000,
    						//flatShading: true 
    						//lightMapIntensity: 0.5

						} );



                const sphereMaterial = new THREE.MeshStandardMaterial( { 
    						color: 0,

    						metalness: 0,
    						envMap: textureCube, // optional environment map
    						envMapIntensity: 20,
    						specular: 0xffc382,
    						shininess: 30,
    						roughness: 0.2,
    						fog: false
						} );
                const sphereMaterialtr = new THREE.MeshStandardMaterial( { 
    						color: 0,

    						metalness: 0,
    						envMap: textureCube, // optional environment map
    						envMapIntensity: 20,
    						specular: 0xffc382,
    						shininess: 30,
    						roughness: 0.2
						} );                

				loader.load( 'ha_ktx.glb', function ( gltf ) {
					gltf.scene.traverse( function( node ) {
        				if ( node.isMesh ) { node.castShadow = true; }
    				} );
					
					mixer = new THREE.AnimationMixer( gltf.scene );
					var action = mixer.clipAction( gltf.animations[ 0 ] );
					console.log(gltf.animations[ 0 ])
					action.play();
					gltf.scene.rotation.y = 3.14;
					hover.add( gltf.scene );
					
				} );		

				hover.scale.set(5,5,5); 
				ballHolder.add( hover );
				playerScene.add(ballHolder);

				loader.load( 'hover.glb', function ( gltf ) {
					gltf.scene.traverse( function( node ) {
        				if ( node.isMesh ) { node.castShadow = true; }
    				} );
					hover.add( gltf.scene );

					
				} );


                loader.load( 'sky.glb', function ( gltf ) {
					gltf.scene.position.y = -300;
					//gltf.scene.getObjectByName('sky_out').blending(THREE.AdditiveBlending);
					sky = gltf.scene;
					playerCamera.add( gltf.scene );
				} );
                loader.load( 'output_ktx.glb', function ( gltf ) {
                	var mainTile = gltf.scene.getObjectByName('land_out');
                	gltf.scene.getObjectByName('land_out').material.lightMap = gltf.scene.getObjectByName('land_out').material.map;
                	gltf.scene.getObjectByName('land_out').material.map = land_map;
                	gltf.scene.getObjectByName('land_out').material.lightMapIntensity = 70;
                	gltf.scene.getObjectByName('land_out').material.bumpMap = land_map;
                	gltf.scene.getObjectByName('land_out').material.bumpScale =12;
                	gltf.scene.getObjectByName('land_out').material.roughness =1;
                	gltf.scene.getObjectByName('land_out').material.metalness =0;
                	//var lod = new THREE.LOD();	
		            
                	var station02;
                	var station03;
					for (let i =tileXmin; i <= tileXmax; i++) {
						for (let j =tileZmin; j <= tileZmax; j++) {
							
							//var lod00 = 
		                	//var lod01 = new THREE.Object3D();
		                	//lod.addLevel( lod00, 2000 );
		                	//lod.addLevel( lod01, 2500 );


							var copy = gltf.scene.getObjectByName('land_out').clone();
							copy.material = gltf.scene.getObjectByName('land_out').material.clone();
							var mat = copy.material;
							//if(i==0&&j==1){
							//	station02 = copy;
							//}
							//if(i==1&&j==1){
							//	station03 = copy;
							//}

							copy.receiveShadow = true;
							copy.position.x+=tileStep*j;
							copy.position.z+=tileStep*i;
							playerScene.add(copy);
					}}
					/*
					loader.load( 'station_space02.glb', function ( gltf ) {
	
						station02.material.lightMap =  gltf.scene.getObjectByName('land_out_station_space02').material.map;
					});

					loader.load( 'station_space03.glb', function ( gltf ) {
	
						station03.material.lightMap =  gltf.scene.getObjectByName('land_out_station_space03').material.map;
					});
					
                	gltf.scene.traverse( function( node ) {
        				if ( node.isMesh ) { node.receiveShadow = true; }
    				} );
    				*/
					//scene.add( gltf.scene );
				} );

				loader.load( 'poles.glb', function ( gltf ) {
					animPolesTexture = gltf.scene.getObjectByName('poles_out_anim').material;
					const lod = new THREE.LOD();
                	var lod00 = gltf.scene;
                	var lod01 = new THREE.Object3D();
                	lod.addLevel( lod00, 2000 );
                	lod.addLevel( lod01, 2500 );
					for (let i =tileXmin; i <= tileXmax; i++) {
						for (let j =tileZmin; j <= tileZmax; j++) {
							const copy = lod.clone();
							copy.receiveShadow = true;
							copy.position.x+=tileStep*j;
							copy.position.z+=tileStep*i;
							playerScene.add(copy);
					}}

				} );
				loader.load( 'theater.glb', function ( gltf ) {
					const lod = new THREE.LOD();
                	var lod00 = gltf.scene.getObjectByName('theater_out');
                	var lod01 = new THREE.Object3D();
                	lod.addLevel( lod00, 2000 );
                	lod.addLevel( lod01, 2500 );
					for (let i =tileXmin; i <= tileXmax; i++) {
						for (let j =tileZmin; j <= tileZmax; j++) {
							const copy = lod.clone();
							copy.receiveShadow = true;
							copy.position.x+=tileStep*j;
							copy.position.z+=tileStep*i;
							playerScene.add(copy);
					}}
				} );
				
				



				
				loader.load( 'wagon_placer.glb', function ( gltf ) {										
					placer = gltf.scene;
					
					loader.load( 'wagon01_comb_ktx.glb', function ( gltf ) {
						gltf.scene.traverse( function( node ) {
        					if ( node.isMesh ) { 
        						node.material.envMap = textureCube;
        						}
    					} );
						const place = placer.getObjectByName('wagon01_pl');
						place.updateWorldMatrix(true,false);
						console.log(placer.matrixWorld);									
						gltf.scene.applyMatrix4(place.matrixWorld);
						playerScene.add(gltf.scene);
					} );

					loader.load( 'wagon02_comb_ktx.glb', function ( gltf ) {
						gltf.scene.traverse( function( node ) {
        					if ( node.isMesh ) { 
        						node.material.envMap = textureCube;
        						}
    					} );
						const place = placer.getObjectByName('wagon02_pl');
						place.updateWorldMatrix(true,false);
						console.log(placer.matrixWorld);									
						gltf.scene.applyMatrix4(place.matrixWorld);
						playerScene.add(gltf.scene);
					} );

					loader.load( 'wagon03_comb_ktx.glb', function ( gltf ) {
						gltf.scene.traverse( function( node ) {
        					if ( node.isMesh ) { 
        						node.material.envMap = textureCube;
        						}
    					} );
						const place = placer.getObjectByName('wagon03_pl');
						place.updateWorldMatrix(true,false);
						console.log(placer.matrixWorld);									
						gltf.scene.applyMatrix4(place.matrixWorld);
						playerScene.add(gltf.scene);
					} );
					/*
					loader.load( 'wagon04_comb_ble.glb', function ( gltf ) {
						gltf.scene.traverse( function( node ) {
        					if ( node.isMesh ) { 
        						node.material.envMap = textureCube;
        						node.material.transparent = true;
        						}
    					} );
						const place = placer.getObjectByName('wagon04_pl');
						place.updateWorldMatrix(true,false);
						console.log(placer.matrixWorld);									
						gltf.scene.applyMatrix4(place.matrixWorld);
						playerScene.add(gltf.scene);
					} );
					loader.load( 'wagon05_comb_ble.glb', function ( gltf ) {
						gltf.scene.traverse( function( node ) {
        					if ( node.isMesh ) { 
        						node.material.envMap = textureCube;
        						node.material.transparent = true;
        						}
    					} );
						const place = placer.getObjectByName('wagon05_pl');
						place.updateWorldMatrix(true,false);
						console.log(placer.matrixWorld);									
						gltf.scene.applyMatrix4(place.matrixWorld);
						playerScene.add(gltf.scene);
					} );
				*/	
				} );
				

				


				loader.load( 'station01.glb', function ( gltf ) {
					
					gltf.scene.getObjectByName('station01_out').material = sphereMaterial;
					

					gltf.scene.getObjectByName('station01_tube_out').material.alphaMap = alphaMap;
					gltf.scene.getObjectByName('station01_tube_out').material.transparent = true;
					sc01 = gltf.scene;
					
					mapScene.add(sc01);
					intersect_map.push(sc01); 
					playerScene.add(sc01.clone());
					
				} );
					
				loader.load( 'station02.glb', function ( gltf ) {
					gltf.scene.getObjectByName('station02_out').material = sphereMaterial;
					

					gltf.scene.getObjectByName('station02_tube_out').material.alphaMap = alphaMap;
					gltf.scene.getObjectByName('station02_tube_out').material.transparent = true;
					sc02 = gltf.scene;
					playerScene.add( sc02.clone() );
					intersect_map.push(sc02);
					mapScene.add(sc02);
				} );
				loader.load( 'station03.glb', function ( gltf ) {

					gltf.scene.getObjectByName('station03_tube_out').material.alphaMap = alphaMap;
					gltf.scene.getObjectByName('station03_tube_out').material.transparent = true;

					gltf.scene.getObjectByName('station03_out').material = sphereMaterial;
					
					sc03 = gltf.scene;

					playerScene.add( sc03.clone() );
					intersect_map.push(sc03);
					mapScene.add(sc03);
					
				} );
				loader.load( 'station04.glb', function ( gltf ) {

					//gltf.scene.getObjectByName('station03_tube_out').material.alphaMap = alphaMap;
					//gltf.scene.getObjectByName('station03_tube_out').material.transparent = true;

					gltf.scene.getObjectByName('station04_out').material = sphereMaterial;

					playerScene.add( gltf.scene );
				} );






            }
            function createInteractiveBall(){
                
                let iball,iballObject;
                let pos = {x: 200, y: 200, z: 200};
                let radius = 20;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 0.1;

                //threeJS Section
                iball = iballObject = new THREE.Mesh(new THREE.SphereGeometry(radius-3), new THREE.MeshPhongMaterial({color: 0xff0505}));
                
                iball.position.set(pos.x, pos.y, pos.z);
                
                iball.castShadow = true;
                iball.receiveShadow = true;

                playerScene.add(iball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );
                //body.fixedTimeStep = 1 / 500;
                //console.log(body);
                //body.setFriction(2000000);
                //body.setRollingFriction(20000000);
                //body.setRollingFriction(20000000);
                //body.setRestitution(20000000);

                body.setActivationState( STATE.DISABLE_DEACTIVATION );
                //body.setCcdMotionThreshold(0.03);
                //body.setCcdSweptSphereRadius(0.2)


                physicsWorld.addRigidBody( body );
                
                iball.userData.physicsBody = body;
                rigidBodies.push(iball);
            }


            function createBall(){
                
                let pos = {x: 0, y: 80, z: 150};
                let radius = 12;
                let quat = {x: 0, y: 0, z: 0, w: 1};
                let mass = 1;

                //threeJS Section
                ball = ballObject = new THREE.Mesh(new THREE.SphereGeometry(2), new THREE.MeshPhongMaterial({color: 0xff0505}));
                
                ball.position.set(pos.x, pos.y, pos.z);
                
                ball.castShadow = true;
                ball.receiveShadow = true;

                //scene.add(ball);


                //Ammojs Section
                let transform = new Ammo.btTransform();
                transform.setIdentity();
                transform.setOrigin( new Ammo.btVector3( pos.x, pos.y, pos.z ) );
                transform.setRotation( new Ammo.btQuaternion( quat.x, quat.y, quat.z, quat.w ) );
                let motionState = new Ammo.btDefaultMotionState( transform );

                let colShape = new Ammo.btSphereShape( radius );
                colShape.setMargin( 0.05 );

                let localInertia = new Ammo.btVector3( 0, 0, 0 );
                colShape.calculateLocalInertia( mass, localInertia );

                let rbInfo = new Ammo.btRigidBodyConstructionInfo( mass, motionState, colShape, localInertia );
                let body = new Ammo.btRigidBody( rbInfo );
                //body.fixedTimeStep = 1 / 500;
                //console.log(body);
                //body.setFriction(2000000);
                //body.setRollingFriction(20000000);
                //body.setRollingFriction(20000000);
                //body.setRestitution(20000000);

                body.setActivationState( STATE.DISABLE_DEACTIVATION );
                //body.setCcdMotionThreshold(0.03);
                //body.setCcdSweptSphereRadius(0.2)


                physicsWorld.addRigidBody( body );
                
                ball.userData.physicsBody = body;
                rigidBodies.push(ball);


				

            }


            function moveBall(){


var characterPos = new THREE.Vector3();
var characterDir = new THREE.Vector3()
ballHolder.getWorldPosition( characterPos );
ballHolder.getWorldDirection( characterDir );

var posCurve = new THREE.Vector3(0,0,0);
if(pt.length>1){
	if (pt[0].distanceTo(characterPos)<500){pt.shift();}
	posCurve =pt[0];
	}
	else 
	{
	autoMode = 0;
	}


                

                let autoDir = new THREE.Vector3();
                if(posCurve){autoDir = posCurve.clone().sub(characterPos)};
                
                autoDir.y = 0;		
                autoDir.normalize();
                //console.log(autoDir)

                let resultantImpulse;
                if(!autoMode){
	                smoothI.push(moveX); 
	                ballHolder.rotation.y-=(smoothI.reduce((a,b) => (a+b)) / smoothI.length)*0.022;
	                smoothI.shift();
	                resultantImpulse = new Ammo.btVector3( characterDir.x*moveZ, 0, characterDir.z*moveZ )
	            	}
              	else{
	                smoothI.push(characterDir.clone().cross(new THREE.Vector3(0,-1,0)).dot(autoDir)); 
	                ballHolder.rotation.y-=(smoothI.reduce((a,b) => (a+b)) / smoothI.length)*0.022;
	                smoothI.shift();
	                resultantImpulse = new Ammo.btVector3(autoDir.x,0,autoDir.z);
	            }

                
                resultantImpulse.op_mul(5);

                let physicsBody = ballObject.userData.physicsBody;
                let test = physicsBody.getLinearVelocity();
                //physicsBody.setAngularVelocity(new Ammo.btVector3(0,0,0))
                //physicsBody.setLinearVelocity(test.op_mul(0.97));
                //physicsBody.applyForce( resultantImpulse);
                test.op_add(resultantImpulse);
                physicsBody.setLinearVelocity(test.op_mul(0.97));
                let side = new THREE.Vector3(test.x(),0,test.z());
             	
                let len = side.length()*0.02;
                characterDir.normalize();
                characterDir.cross(new THREE.Vector3(0,1,0));
                side.normalize();

                smoothZ.push(characterDir.dot(side)*len);
                smoothX.push(test.y());
                hover.rotation.x = (smoothX.reduce((a,b) => (a+b)) / smoothX.length)*0.005
                hover.rotation.z = -(smoothZ.reduce((a,b) => (a+b)) / smoothZ.length)*0.4;
                	
                smoothX.shift();
                smoothZ.shift();
                moveX = 0;
                moveZ = 0;



            }

            function updatePhysics( deltaTime ){


            	
            	ballHolder.position.copy(ball.position);
            	smoothPY.push(ball.position.y);
            	ballHolder.position.y = (smoothPY.reduce((a,b) => (a+b)) / smoothPY.length)
	           	smoothPY.shift();

            	let handVec = new THREE.Vector3()
							ballHolder.getWorldPosition(handVec)
							handVec.y+=6;
							handVec.y*=1;
            	//controls.target= handVec;
            	//controls.update();
                // Step world
                

                physicsWorld.stepSimulation( deltaTime,1);


                // Update rigid bodies
                for ( let i = 0; i < rigidBodies.length; i++ ) {
                    let objThree = rigidBodies[ i ];
                    let objAmmo = objThree.userData.physicsBody;
                    let ms = objAmmo.getMotionState();
                    if ( ms ) {

                        ms.getWorldTransform( tmpTrans );
                        let p = tmpTrans.getOrigin();
                        let q = tmpTrans.getRotation();
                        objThree.position.set( p.x(), p.y(), p.z() );
                        objThree.quaternion.set( q.x(), q.y(), q.z(), q.w() );

                    }
                }	

            }

            function renderFrame(){

                let deltaTime = clock.getDelta();

                
    						
                
                

                //animPolesTexture.map.offset.y += deltaTime*0.3;

                //sc01.children[0].children[0].rotation.y +=deltaTime*0.3;
                //sc02.children[0].children[0].rotation.y +=deltaTime*0.3;
                //sc03.children[0].children[0].rotation.y +=deltaTime*0.3;
                moveBall();
                cameraHolder.rotation.y = ctrl.rot.y*2;
                ctrl.update();
                moveX = ctrl.velocity.x*1.5;
                moveZ = ctrl.velocity.z*1.5;

                //const campo
                playerCamera.getWorldPosition(mapCamera.position);
                mapCamera.position.y = 4000;

                mixer.update( deltaTime*0.65 );

                updatePhysics( deltaTime );
    						
    						renderer.render( activeScene, activeCamera );

                requestAnimationFrame( renderFrame );

            }

            function autoChange(){
 							document.getElementById("autoButton").style.display = "none";
 							pt = [];
            }

            function mapChange(){
            	const cameraSwith = activeCamera;
            	if(cameraSwith==mapCamera){
            		activeScene = playerScene;
            		document.getElementById("shopButton").style.display = "block";
            		document.getElementsByClassName("movement-pad")[0].style.display = "block";
            		activeCamera = playerCamera;
            	};
            	if(cameraSwith==playerCamera){
            		activeScene = mapScene;
            		document.getElementById("shopButton").style.display = "none";
            		document.getElementsByClassName("movement-pad")[0].style.display = "none";
            		activeCamera = mapCamera;
            	};  
            }

            function shopChange(){
            	const cameraSwith = activeCamera;
            	if(cameraSwith==shopCamera){
            		//activeScene = playerScene;
            		document.getElementById("mapButton").style.display = "block";
            		document.getElementsByClassName("movement-pad")[0].style.display = "block";
            		activeCamera = playerCamera;
            	};
            	if(cameraSwith==playerCamera){
            		//activeScene = mapScene;
            		document.getElementById("mapButton").style.display = "none";
            		document.getElementsByClassName("movement-pad")[0].style.display = "none";
            		activeCamera = shopCamera;
            	};  
            }


        </script>
    </body>
</html>